#!/bin/sh

if [ -f "$1" ]; then
	tipo="$(file -b --mime-type "$1" | grep 'application/pgp$' | rev| cut -d' ' -f1 | rev)"
	case $tipo in
		"application/pgp") gpg -d "$@" ;; #|| gpg ;;
		*) [ "$(printf "s\\nn"| dmenu -p 'encriptar simetricamente? ')"  = 's' ] \
			&& gpg -ca "$1";; #encriptacion simetrica
	esac
fi
[ -n "$1" ] && exit

verde='\033[0;32m'
nocolor='\e[0m'
clave=$(fzf --prompt='gestor criptogr치fico: ' << GONZALO
generar nuevo par de llaves
importar clave
eliminar par de llaves privada-publica
exportar a clave publica
desencriptar volcando a archivo
desencriptar en directorio
desencriptar sin volcado
encriptar para otro usuario (asimetricamente)
encriptar asimetricamente
servidores de claves
firmar digitalmente
exportar clave privada
editar clave
listar claves privadas
listar claves publicas
verificar firma digital
encriptar en una imagen
encriptar simetricamente
encriptar firmando digitalmente (asimetricamente)
extraer archivo/mensaje de una imagen
eliminar archivo de forma segura
revocar clave
GONZALO
)

case $clave in
	"generar nuevo par de llaves") gpg --full-generate-key;;
	"importar clave") a="$(file . -- * | grep 'Public-Key' | grep -v 'message')"
		if [ -z "$a" ]; then
			echo "no hay claves publicas en el presente directorio"
		else 
			for gonza in $(echo "$a" | fzf --cycle --height=15 -m | cut -d':' -f1); do
				gpg --import "$gonza"
			done
		fi ;;
	"eliminar par de llaves privada-publica") gpg --list-keys \
		&& for gon in $(gpg -k | awk '/pub/{getline; print}' | tail -n +2 | fzf --cycle --height=15 -m); do
			gpg --delete-secret-and-public-key $gon
		done && gpg -k;;
	"exportar a clave publica") gpg --list-keys \
		&& a=$(gpg -k | awk '/pub/{getline; print}' | tail -n +2 | fzf --cycle --height=15) \
		&& gpg -a --export -o $(echo "$a" | tr -d ' ').pub "$a";;
	"desencriptar volcando a archivo")
		for gon in $(find . | fzf --cycle --height=15 --prompt='elige archivo: ' -m); do
			printf '%b' "desencriptando ${verde}$gon${nocolor} \\n" \
				&& gpg -o "$gon".desencriptado --decrypt "$gon"
		done;;
	"desencriptar sin volcado") archivo=$(file -- *  | grep -i 'PGP message') || exit
		for gon in $(printf "$archivo" | fzf --cycle --reverse --prompt='archivo a desencriptar: ' -m | cut -d':' -f1); do
			printf '%b' "desencriptando ${verde}$gon${nocolor} \\n" && gpg --decrypt "$gon"
		done;;
	"encriptar para otro usuario (asimetricamente)"|"encriptar asimetricamente") gpg --list-keys && printf "destinatario: " \
		&&  a=$(gpg -k | awk '/pub/{getline; print}' | tail -n +2 | fzf --cycle --height=15) \
		&& printf "archivo a cifrar: " && b=$(find . -maxdepth 1 | fzf --cycle --height=15) \
		&& gpg -v -a -o mensaje.cifrado --encrypt --recipient "$a" "$b";; 
	"servidores de claves") keyserver="hkp://pool.sks-keyservers.net" \
		a=$(printf "subir clave publica a servidor de claves\\nbuscar clave publica en servidor de claves\\ndescargar clave publica de servidor de claves\\n"|
		fzf --cycle --height=10)
			case $a in
				"subir clave publica a servidor de claves")
					gpg -k && gpg --send-keys --keyserver "$keyserver" \
						"$(gpg -k | awk '/pub/{getline; print}' | tail -n +2 | fzf --cycle --height=15| tr -d ' ')";;
				"buscar clave publica en servidor de claves")
					pub="$(fzf <<- GONZALO
					buscar llaves publicas
					cotejar llaves publicas locales con los servidores
					GONZALO
					)"
					case $pub in
						"cotejar llaves publicas locales con los servidores")
							a="$(gpg -k | awk '/pub/{getline; print}' | tail -n +2 | fzf --cycle --height=15| tr -d ' ')" \
								&& gpg --keyserver "$keyserver" --search-keys "$a";;
						"buscar llaves publicas")
							printf "llave a buscar: " && read -r llave \
								&& gpg --keyserver "$keyserver" --search-keys "$llave";; 
					esac ;;
				"descargar clave publica de servidor de claves")
					printf "clave a descargar: " && read -r llave \
						&& gpg --keyserver $keyserver --recv-keys $($(gpg --keyserver "$keyserver" --search-keys "$llave") \
						&& [ $(echo "s\\nn" | dmenu -p 'descargar?: ') = "s" ]) ;;
			esac ;;
	"firmar digitalmente")
		for gon in $(find . -maxdepth 1 | fzf --cycle --height=15 --prompt='elige archivo a firmar: ' -m); do
		       printf '%b' "firma para ${verde}$gon${nocolor} \\n" && gpg --clearsign "$gon"
	       done;;
	"exportar clave privada")
		gpg --list-secret-keys && a="$(gpg --list-secret-keys | awk '/sec/{getline; print}' | fzf --cycle --height=15)" \
			&& gpg -ao "$(echo "$a" | tr -d ' ')".priv --export-secret-keys "$a";;
	"encriptar firmando digitalmente (asimetricamente)") gpg --list-keys \
		&& a=$(gpg -k | awk '/pub/{getline; print}' | tail -n +2 | fzf --cycle --height=15 --prompt='usuario origen: ') \
		&& b=$(gpg -k | awk '/pub/{getline; print}' | tail -n +2 | fzf --cycle --height=15 --prompt='usuario destinatario: ') \
		&& c="$(find . | fzf --cycle --height=15 --prompt='archivo a firmar: ')" \
		&& gpg -a -u "$a" --sign -o "$c.asc" --encrypt -r "$b" "$c";;
	"listar claves privadas")
		gpg --list-secret-keys --keyid-format LONG;;
	"listar claves publicas")
		gpg --list-public-keys --keyid-format LONG;;
	"verificar firma digital")
		for gonza in $(find . -maxdepth 1|fzf --prompt='elige archivo: ' -m); do
			printf '%b' "firma para ${verde}$gonza${nocolor} \\n" && gpg --verify "$gonza"
		done
		;;
	"encriptar en una imagen")
		archivo="$(find . -maxdepth 2 | fzf --prompt='archivo a embeber: ')" \
			&& imagen="$(file --mime-type -- *  | grep 'image/jpeg\|image/png' |fzf --prompt='imagen a usar: ')"
					if [ -n "$(echo $imagen | grep 'image/jpeg')" ]; then
						imagen="$(echo "$imagen" | cut -d':' -f1)" \
							&& printf "%b" "${verde}pon contrase침a \\n" \
							&& steghide embed -ef "$archivo" -cf "$imagen"
					else
						imagen="$(echo "$imagen" | cut -d':' -f1)"
						echo "$imagen"
						convert $imagen $imagen.jpg \
							&& printf "%b" "${verde}pon contrase침a \\n" \
							&& steghide embed -ef "$archivo" -cf "$imagen.jpg"
					fi;; 
	"extraer archivo/mensaje de una imagen")
		for gon in $(file --mime-type -- * | grep 'image/jpeg' | fzf -m | cut -d':' -f1); do
			printf '%b' "${verde}pon contrase침a para desencriptar la imagen${nocolor} \\n" \
				&& steghide extract -sf "$gon" -xf "$gon".unhided
		done;;
	"desencriptar en directorio") a="$(file --mime-type -- * | grep 'application/pgp$')" \
		&& b="$(printf "%s" "$a" | fzf -m)" && [ -n "$b" ] \
		&& name=$(echo "$b" |cut -d' ' -f1 |tr -d ':') \
		&& tipo="$(echo "$b" |rev | cut -d' ' -f1|rev)" \
		&& [ -z "$b" ] && exit
		case $tipo in
			application/pg*) for gon in $name; do
				printf '%b' "${verde}$gon${nocolor} \\n" && gpg -d "$gon" || echo fallo
			done
		esac
		;;
	"editar clave") gpg --edit-key "$(gpg -k | awk '/pub/{getline; print}' | tail -n +2 | fzf --cycle --height=15)";;
	"encriptar simetricamente") for i in $(find . -maxdepth 1 | fzf -m ); do
		gpg -ca "$i"
	done;;
	"eliminar archivo de forma segura")
		for gon in $(find . -maxdepth 1 | fzf -m); do
			shred -u "$gon"
		done;;
	"revocar clave") gpg -k && gpg --output revoke.asc --gen-revoke \
		$(gpg --list-public-keys --with-colons | sed -ne '/^pub:/,/^fpr:/ { /^fpr:/ p }' | cut -d: -f10| fzf --height 15%) \
		&& [ "$(echo "s\\nn"  | dmenu -p 'importala al anillo?: ' )" = 's' ] && gpg --import revoke.asc ;;
esac
